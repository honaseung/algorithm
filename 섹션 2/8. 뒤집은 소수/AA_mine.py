import sys
#sys.stdin = open('in4.txt')

#문제랑은 단 1 도 관계 없지만
#문자열에서 rfind 라는 녀석을 쓰면
#찾는 문자 중 가장 높은 인덱스 값을 찾아준다고 한다.
#아직 써보진 않았지만 쓸곳은 많아 보인다.
#추가로 find 는 없을시 -1 을
#index 는 없을시 에러를 리턴한다.
N = int(input())
strArr = list(input().split())

#reversed 활용법
#리스트로 만들어 사용한다.
#ex) '32' -> [2, 3]
#list(reversed(strArr[3]))

#자릿수를 거꾸로 뒤집어 숫자로 표현하기 위해서 각 자릿수의 10 의 승수와
#각 자릿수의 값을 추출하여 뒤집어서 곱해주었다.
#오리지날 리스트를 파괴 및 변형시키지 않는 방식이다.
def reverseSafe(x: str) :
    #이 문제에서는 숫자를 뒤집기 때문에 그냥 더하기를 활용해도 괜찮았으나
    #만약 문자열 뒤집기나 리스트 뒤집기를 하면 이보다 더 효율적인 방법이 있다.
    #tmp 변수를 만들어서 변경 시켜주는 것이다.
    #이때 중요한것은 인덱스가 처음과 마지막에서 점점 간격이 좁혀져 오다가
    #교차되는 순간이 존재하기때문에 반드시 인덱스 범위는 x - 1 까지가 아닌
    #x // 2 까지이다.
    num: int = 0
    for i in range(len(x)) :
        num = num + (10 ** (len(x) - i - 1)) * int(x[len(x) - i - 1])
        '''
        센세 방식
        나와 다른것은 자릿수를 i 라는 변수로써
        일일이 잡아주기 보다
        위 코드로 치면 이미 뒤집고 있는 숫자인
        num 에 10 을 계속 곱하면서 자릿수를 잡아주었다.
        훨씬 간결한 방식이긴하지만
        수작업인 내 방식도 알아두면 좋을것같다.
        t = x % 10
        res = res * 10 + t
        '''
    return num

#오리지날 리스트를 파괴 및 변형시키는 방식이 되려 하였으나
#몇 번의 시도끝에 되지 않는다고 판단하여 새로운 리스틀 만들어서
#리턴 시키는 방향으로 작성되었다.
#그리고 만들기만 했지 안쓸래 내꺼가 사실 더 좋은거같아서(멋있는거같아서)
#그래서 str 객체를 파괴 및 변형시키는 방법은 있긴한가??
def reverse(x: list) :
    elementReversedList = []
    for i in range(len(x)) :
        str = x[i]
        #이 방식도 알아두면 굉장히 효율적이고 좋을것같다.
        #문자열을 리스트화 시키고 그것을 다시 reversed 함수에 담아서
        #reversed 된 리스트를 빈 문자열에 join 시켜서 문자열을
        #뒤집기하는 방식이다.
        #물론 int 화는 여기서만 사용하는거다.
        str = int(''.join(reversed(list(str))))

        #for j in range(len(str) // 2) :
        #    tmp = str[j]
        #    인덱스에 접근할때는 항상 항상 주의 또 주의하길 바란다.
        #    str 객체에는 변형을 줄 수가 없다.
        #    강제로 변형시키려면 어떻게 해야할까?
        #    str[j] = str[len(str) - j - 1]
        #    str[len(str) - j - 1] = tmp

        elementReversedList.append(str)
    

def isPrime(x: int) :
    #소수를 구할때 굳이 꼭 x 나 x - 1 까지가
    #아니라 그냥 x // 2 까지만 해도 상관없지 않을까
    #애시당초 x 가 약수로 x - 1 을 가질 경우가 존재 할까?
    #이렇게 생각해보면 x // 2 까지만 해도 충분하지 않을까??
    #라는 생각에 짜는 코드이다.

    #미래에서 검거하러 왔습니다. 10 분전의 나
    #멍청아 너무 큰 수 들만가지고 생각했어
    #엄청 작은 숫자들을 생각해보라고
    #예를 들면 제일 작은 소수 2 같은경우라면
    #그냥 조건을 뚫어버릴수도 있다고!!
    #멍청이라고 한건 미안 시도는 좋았어
    #근데 조금 아쉬었어!!

    #라인 76 너는 자유다.
    #니가 옳았어.
    #발상이 좋았어. 다만
    #약수는 자기 자신 나누기 2 까지만 존재하기에
    #그런거지. 너가 다 맞은건 아니야.
    #아무튼 자유다. 미안하다.
    #range(2, x // 2 + 1) 까지도 정확했어. 축하햏.

    #1 이 문제다 숫자가 1이라면 아래 for 구문을 타지 않게되고
    #바로 for else 구문으로 떨어지는듯하다.
    #일단 while 문으로 변경하겠으나
    #이런 예외사항을 어떻게 처리하는지 강의 내용을 잘봐야할듯하다.
    #다시 한번 정리
    #while 문은 index 컨트롤을 내가 직접한다.
    #for 문은 index 컨트롤을 자동으로 해준다.

    #이제는 2 까지 걸러버리네
    #환장하겠군!!
    #while 은 어지간하면 봉인하는걸로!!
    #가 아니라 원인 파악 제대로 해야한단다!!
    #반복 조건때문이다.
    #진짜 2 하나 때문에 걸리는데 다른 숫자면 문제가 안되는데!! 웨!!
    #접근 방식의 문제이다.
    #2 로 나눈 몫 까지만 접근한다는 방식은 index 를 이용할 경우 유효하다.
    #여기서는 약수 리스트의 index 를 활용하는 것이 아니기에 이런 방식은 유효하지 않다.
    #따라서 2 로 나눈 몫 까지만 이용하는 방식은 접자.
    #이 아이디어가 나온 발상은 x % x - 1 은 반드시 0 이 될 수 없으니 할 필요가 없다는 것에서
    #시작되었는데 뭐 틀린 발상은 아니지만 너무 큰 숫자들만을 생각한 발상이었다.
    #작은 숫자에는 문제가 된다. 그 발상 찾아!! 검거해!!
    #이봐 라인 95 녀석은 라인 67 이 검거했어
    #for i in range(2, x // 2 + 1) :
    i = 2
    while i < x + 1 :
        #이 조건 잘 생각해봐
        #이상하지??
        #절대로 True 를 리턴할 수 없어
        #왜냐하면 x % i == 0 를 먼저 체크하면
        #x % x 도 i == x 보다 먼저 체크 할테고
        #x % x 는 반드시 0 이니까!!
        #멈추는 조건에 대해서도 유의해야할 것 같아
        #최대, 최소의 양극단과 시작 그리고 멈추의 양극단에 대해
        #항상 주의하자!!
        if i == x :
            return True
        elif x % i == 0 :
            return False
        i += 1

    #1 은 while 문을 타지않기 때문에 None 을 리턴할테지만
    #None 은 null 또는 undefinded 와 달리 출력 자체가 안되는듯 하다.

for i in range(N) :
    targetNum = reverseSafe(strArr[i])
    if isPrime(targetNum) :
        #오리지날 리스트를 파괴하지 않았기 때문에 아래처럼 출력하면
        #이상한 답(변형되지 않은 값)들이 나온다.
        #reverseSafe 함수를 다시 호출해서 출력하거나 차라리
        #오리지날 리스트를 파괴하고 변형하는 방식을 취해보자.
        #아니 아니지 reverseSafe 함수를 다시 호출하는 것이 아니라
        #reverSafe 함수의 리턴값을 변수에 저장해서 활용하면 되지.
        #만!! 그래도 해보는데 의미가 있다.
        print(targetNum, end = " ")
    

#문자열 int 화 시켜서 뒤집기까지 완료
#다했어
