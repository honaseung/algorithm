import sys
#sys.stdin = open('in5.txt')

N = int(input())
arr = list(range(2, N + 1))
#리스트의 길이가 계속 변경되니까 for 문 보다는 while 문이 좋겠다.
#더 정확히 말하자면 range(len(arr)) 은 비교할때마다 실행되지 않았다.
#한번 정해진 값이 변하지 않았기에 인덱스 값이 넘어가버렸다.
#위의 내용은 확실하지않다.
'''
i = 0
while i < len(arr) :
    j = i + 1
    while j < len(arr) :
        if arr[j] % arr[i] == 0 :
            arr.pop(j)
        j += 1
    i += 1
print(len(arr))
'''

#흠 답은 일단 맞는데
#시간이 너무 오래 걸려서 타임 아웃이 난다.

#오래 기다리셨습니다
#다시 가볼까요
#위의 풀이에서 한가지 오해한것
#i 를 인덱스로 갖는 수 보다 큰 모든 숫자에 대해서 나머지가 0 인지 조사하며 pop 할 필요가 없다
#i 를 인덱스로 갖는 수의 배수만 pop 해주면 된다.
#아이디어는 좋았따. 아름다웠따.

#인덱스로 접근하는것이 아니기에 i = 0 이 아닌 i = 2 로 작업
'''
i = 2
while i < len(arr) :
    j = i
    #i * j 한 값이 N 보다 크면 N 까지의 소수를 구하는 의미가 없으니까
    while i * j <= N :
        try: 
            idx = arr.index(i * j)
            j += 1
        except: 
            j += 1
            continue
        arr.pop(idx)
    i += 1
print(len(arr))
'''
#pop 이나 index 때문임을 증명하고자 하였으나...
#실패

#하지만 이렇게 해도 타임아웃이 발생한다.
#아무래도 각기 다른 값을 저장한 리스트는 생각보다 무거운가보다.
#아니 무거운건 pop 이었나

#결국 해내지 못했군
#정답 공개하자.
#아니 포기하지마.
#해치웠나.
#기존 풀이는 뭐가 문제였을까?

#1 부터 N 까지의 수 중에서 소수를 구하는 코드이다.
#cnt 를 N 으로 두고 소수가 아닌 수를 발견할때마다 -1 하는 방식으로 진행한다.
#하지만 여기서 문제는 소수는 원래 1 부터가 아닌 2 부터 시작되기 때문에
#밑의 코드에서조차 2 부터 시작한다.
#cnt 는 N 으로 초기화 되어 있고 소수가 아닌 수가 발견될때마다 -1 이 되는데
#코드가 2 부터 시작하기때문에 소수가 아닌 1 은 걸러주질 못한다.
#코드를 1 부터 시작하도록 바꾸기엔 변경점이 너무 많고 예외 사항이 많다.
#따라서 cnt 를 N 이 아닌 N - 1 로 초기화 하는게 맞다.
cnt = N - 1
#리스트 다시 초기화 위에꺼 안씀!
arr = [0] * (N + 1)
for i in range(2, N + 1) :
    #이미 앞에서 소수가 아님이 체크가 완료된 녀석들은 굳이 진행할 필요가 없으니 패스
    if arr[i] == 1 :
        continue
    #i * j 로 인덱스에 접근하기 때문에 인덱스 에러 발생 방지를 위해
    #범위를 N 을 i 로 나눈 몫까지만 돌도록 하였으나
    #N 은 그대로 두고 step 을 i 로 둠으로써
    #i 부터 시작하여 i 의 배수만 돌도록 하는 방식이 있다.
    #너무 강추하는 방식이다.
    for j in range(i, N // i + 1) :
        if arr[i * j] == 0 :
            #소수가 아닙니다 라는 체크
            arr[i * j] = 1
            #카운트를 늘리는게 아닌 줄이는 아이디어는 좋았다.
            #그래도 카운트를 할때는 늘상 조심하자.
            cnt -= 1
print(cnt)
