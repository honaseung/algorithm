import sys
sys.stdin = open('in1.txt')

N, C = map(int, input().split())
stationList = sorted([int(input()) for _ in range(N)])


#print(stationList)
#졸다가 차 한잔 따르면서
#훌륭한 발상이 떠올랐다.
#가끔은 그저 앉아서 생각하는것보다
#잠깐 일어나서 정리하는것도 좋은 습관이지.

#발상은 이러하다.
#말을 실제로 집어넣는다고 생각하면 된다.
#한마리 한마리씩 집어넣는다고 생각해보면
#처음 두마리는 무조건 제일 작은 좌표와
#제일 큰 좌표에 각각 들어가게 될것이다.
#문제는 이다음 부터다.
#나머지 말들은 어떻게 집어넣을것인가.
#아직 이 부분에 대한 답은 내리지 못했다.
lt = stationList[0]
rt = stationList[N - 1]

#발상1 :
#   3 번째 말부터 매번 중간 지점에 말을 한마리씩 추가 배치한다.
#   이경우에는 구간이 계속 분열하여 2 의 n 승?? 만큼의 구간이 생긴다.
#   이게 가장 정답에 가까워 보이는데 결정알고리즘이라기보다는 동적계획법 같아 보인다.

#발상2 :
#   3 번째 말부터 이미 정해둔 거리만큼 말을 한마리씩 추가 배치한다.
#   이경우에는 거리를 어떻게 정할것이냐의 문제와 정한 거리에 마구간이 있는지
#   없다면 가장 가까운 마구간은 어디인지 알아야만하는 문제가 있다.

#흐음.....
#어렵네
#뭐여 일단 정렬은 맞았네?? 사실 틀릴줄 알고 안했는데
#결론적으로 구하고자 하는것이 거리라는점을 다시 기억하자.
#이 사실들은 적어둔채로 쉬엇!

#오랜만이다. 돌아왔구나 환태식이.
#센세의 방식은 두 말의 최대 거리를 lt 와 rt 의 중간값이라고 가정하고
#그 중간값을 대입하면서 가능한지 아닌지를 체크하며 진행한다.
def cntStation() :
    cnt = 1
    for i in range(1, len(stationList) - 1) :
        #단순히 근접한 마구간끼리만 비교해서는 안돼!!
        #다음 마구간이 안되면 그 다음 또 그 다음으로 진행해야해.
        #if stationList[i] - stationList[i - 1] >= mid :
        #위에서 i 를 마구간중 마지막 두번째 까지만 접근할 수 있도록 했어.
        #그래야지 아래에 있는 j 가 항상 마지막까지 접근할 수 있을거 같아.
        #또한 j 는 i 다음 마구간부터 시작하도록 했어.
        #굳이 똑같은 마구간을 두번 체크하는 불상사는 없어야하니까.
        #물론 똑같은 마구간을 두번 체크한다고 하더라도 조건은 성립할 수 없어서
        #답은 틀리지않을것 같아.
        for j in range(i + 1, len(stationList)) :
            if stationList[i] - stationList[j] >= mid :
                cnt += 1
    return cnt

res = 0
while lt <= rt :
    mid = (lt + rt) // 2
    cnt = cntStation()
    if cnt >= C :
        lt = mid + 1
        res = mid
    elif  cnt < C :
        rt = mid - 1

print(res)

#어려웡. 도움!!
#포기. 나중에 내 풀이를 다시 만들자.
#일단은 센세 풀이로 가자.