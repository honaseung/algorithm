import sys
#sys.stdin = open('input.txt')

#그리디에 대해서
#그리디 알고리즘은 설명이
#너무 간단해서 딱히 적을 말이 크게 많지는 않다.
#정렬을 통해서 문제를 해결하는 알고리즘이다.
#그래서 정렬하기 위해서는 당연하게도
#리스트를 활용해야만 한다.
#다만 단순히 정렬만해서 끝날 문제라면
#문제도 아니겠지??
#결론적으로 그리디 알고리즘에서 중요한것은
#무엇을 어떻게 정렬할것인가?? 가 될 것이다.

n = int(input())
#리스트를 담을 리스트
infoList = []
for _ in range(n) :
    #사실 어떤 방향으로 가닥을 잡아서 리스트에 담을지
    #여러 가지 방법이 있겠지만
    #예를들면 딕셔너리 왜냐하면 들어오는 인풋값이
    #그리 길지가 않다. 두개씩만 들어오니 딕셔너리로 받을수도 있다.
    #여기서는 가장 익숙하고 또 그래서 편한 리스트를 이용하였다.
    #그리고 하나 더 중요한것은 읽어온 요소들을 int 로 형변환 해준다는것이다.
    #str 의 정렬과 int 의 정렬은 매우 다르다.
    #전에도 말한적 있으니 이상 줄이도록 하지.
    infoList.append(list(map(int, input().split())))
#정렬을 하는 기준을 x[1] 으로 하였다.
#이렇게 해둔 이유는 x[1] 이 의미하는것은
#회의가 끝나는 시간이다.
#회의가 끝나는 시간을 기준으로 정렬해야한다는 판단은
#회의가 언제 시작하든 끝나지 않는다면 다음 회의를 진행할 수 없다.
#따라서 가장 많은 회의를 진행하려면 회의가 끝나는 시간이 작아야만 한다.
#sort 함수를 사용할때 매개변수로 사용하는 key
#그리고 key 를 활용하기위한 lambda 에 대해서 사용법에 익숙해지자.
infoList.sort(key = lambda x: x[1])

#회의 횟수를 계산하는 함수이다.
def cntTime() :
    #회의가 끝나는 시간을 의미하는 변수이다.
    #초기값은 0 으로 잡았다.
    #초기값을 0 으로 잡은 이유는
    #회의 끝 시간이 다음 회의보다 작거나 같을 경우
    #다음 회의를 진행하고 또 다음 회의 끝 시간을 담을 수 있기 때문인데
    #초기값을 0 으로 잡는다면(혹은 최솟값)
    #무조건 첫 회의의 끝 시간을 담을 수 있다.
    fin = 0
    #회의를 몇 번 진행하였는지 횟수를 세는 변수이다.
    cnt = 0
    for x in infoList : 
        #회의의 시작 시간이
        #이전 회의의 끝시간과 같거나 크다면
        if x[0] >= fin :
            #이전 회의의 끝시간을 이번 회의의 끝시간으로 변경한다.
            fin = x[1]
            #회의를 진행하였으므로 회의 횟수를 저장하는 변수의 값을 증가시킨다.
            cnt += 1
    return cnt

res = cntTime()
print(res)