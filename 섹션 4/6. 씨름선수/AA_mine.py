import sys
sys.stdin = open('in1.txt')

#그리디를 활용해야하는 경우!!
#각각의 요소가 서로서로 비교한다??
#각각의 요소가 서로서로 비교한다가 아니더라도 쨋든 비교한다??
#들어오는 정보의 세트가 무겁지않다??(ex 한 줄에 두개의 정보정도??)
#뭐 이정도?? 사실 전부 추측임 ㅋㅋ
#근데 근거는 있어보임.

N = int(input())
playerList = []
for _ in range(N) :
    h, w = map(int, input().split())
    playerList.append((h, w))
playerList.sort(key = lambda x: (x[0], x[1]))

#cnt 를 N 으로 잡은것은
#매우 영리하다고 생각한다.
#일단 모든 선수를 영입한다고 가정하고
#영입할 수 없는 선수들을 제외하는 소거법?? 방식이다.
#때로는 cnt 를 0 이나 1 로 시작하여
#숫자를 늘려나가도 좋겠지만
#때로는 전체에서 하나씩 제거해나가는 방식도
#굉장히 유용할 것이다.
cnt = N
#포인터에 대해서 많이 까먹었드라?? ㅋㅋ
#야 그거 까먹으면 안돼!!
#포인터가 얼마나 중요헌디.
#그런 의미에서 이번 포인터 한번 정리하자.
#다중 for 문으로 포인터를 잡고 처리하고 있고
#또 다중 for 문으로 포인터를 잡으면 포인터 컨트롤이 편하다.
#다만 다중 for 문으로 포인터를 잡으면 편리한만큼 세밀한 컨트롤이 불가능하다.
#다중 for 문으로 포인터를 컨트롤 하면
#기준점이 되는 포인터가 움직이는 포인터를 결코 넘지 않는다.
#움직이는 포인터는 기준점을 고정시켜두고 움직인다.
#결론적으로 여기서 이런 방식의 포인터 처리를 하는 이유 혹은 할 수 있는 이유는
#정렬후에 요소들을 서로 비교함에 있어서
#기준점 이전의 요소들에 대해서는 신경쓰지 않아도 되기 때문이다.
#정렬하는 방식에 따라서 cnt 도 달라질 것 같다.
#아래는 기준점 포인터 처리
for i in range(len(playerList) - 1) :
    #아래는 움직이는 포인터 처리
    for j in range(i + 1, len(playerList)) :
        #문제에서 주어진대로 키 또는 몸무게 둘 다 작다면 해당 선수는 아웃
        if playerList[i][0] < playerList[j][0] and playerList[i][1] < playerList[j][1] :
            #아웃되기때문에 영입될 선수를 한 명 줄여준다.
            cnt -= 1
            #기억해둘것!!
            #break 문은 for 문을 정지 시키지만
            #다중 for 문일경우 하나만 정지 시킨다.
            #그리고 아까는 break 가 없어서 오답이 났어요.
            #그러니 break 나 continue 걸어야 할 때를 잘 생각하셔요.
            #아 추가로 다중 for 문을 전부 정지 시키는
            #키워드는 뭘까에 대해서 궁금해진다.
            #궁금증은 언제가 해결할 문제로 남겨두고 넘어갈랭 ㅋㅋ
            break
#print(cnt)

#강의 보고 왔습니다.
#다중 for 문 아니어도 풀 수 있으니 해봅시다.

cnt = N

#largest 또는 lowest 기법이다.
#최대값 또는 최소값을 생성하고
#그 값을 계속 갱신하며
#값들에 대한 비교를 해가면서
#원하는 결과값을 찾아가는 기법이다.
#여기서는 lowest 기법을 사용한다.
#센세와는 풀이가 다르다.
#정렬의 방식 자체가 다르기 때문이다.

#최소값이라고 반드시 float('inf') 를 이용한
#최대값 만들기를 하면 안됀다.
lowest = float('inf')
#여기서는 초기값으로 첫번째 선수의 값을
#초기값으로 설정한다.
#이렇게하는 이유는
#첫번째 선수는 반드시 예외처리를 해줘야한담.
#첫번째 선수는 반드시 최소값으로 들어가야 하면서
#동시에 반드시 제외될 필요는 없다.
lowest = playerList[0][1]

#문제는 기준보다 키큰 상대 모두와 비교를 해야하는데
#그걸 for 문 하나와 최소값으로 표현해야한다는것이다.
#나머지는 투비깐티뉴로 하자.
for i in range(1, N) :
    if playerList[i][1] < lowest :
        cnt -= 1
        lowest = playerList[i][1]
print(cnt)

#나름의 방식은 떠올렸어.
#슬라이스와 min 함수를 이용해서
#최소값을 뽑고 거기서 매번 비교하는거지
#다만 문제는 튜플을 슬라이스 할 수 없다는 거지.

#이 방식이 먹히지 않았고
#센세의 방식도 전부 이해했어.
#다만 센세의 방식은 최대값을 활용한 비교이고
#나의 방식은 최소값을 활용한 비교이기에
#코드가 달라질 수 밖에 없지.
#그런데 그걸 할 수가 없어.
#이건 내 역랑 부족이고
#이해가 덜 되었기때문이야.
#나중에라도 다시 해볼수 있다면 다시 해보자.

#포인터에 대해서 까먹은게 확실해
#까먹을 수 있지. 괜찮아. 다시 하면 돼.
#어차피 나는 이 강의를 한번만 듣고
#끝낼 생각이 없었어.
#머릿속으로 정리하는것도 좋아.
#혹은 이렇게 주석으로써 정리하는것도
#당연히 좋아.
#그치만 가장 중요한건 마지막엔 까먹지 않는거야.