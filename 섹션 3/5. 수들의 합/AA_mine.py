import sys
#sys.stdin = open('input.txt')

N, M = map(int, input().split())
numArr = list(map(int, input().split()))

cnt = 0

'''
for i in range(N) :
    sum = 0
    sum += numArr[i]
    #항상 조건을 주의해서 봐야해
    #그러기 위해서는 문제의 틀만 잡고 코드를 짜는 습관보다는
    #틀을 잡고 예외사항을 정리해두고
    #코드에 진입하는게 좋겠지.
    for j in range(i + 1, N + 1) :
        #생각지도 못한 예외사항들이 등장하곤한다.
        #코드가 디테일할수록 좋은거같다.
        #틀을 잡고
        #디테일하게 작성하고
        #쳐내는 방식이 좋은걸까??
        if sum < M :
            if j < N: sum += numArr[j]
        #아래가 elif 라면
        #합을 한뒤에 그 합에 대한 검사를 진행하지않고
        #다음 idx 로 접근하게된다.
        #따라서 합을 했으면 검사할 수 있도록 코드를 수정하였다.
        if sum == M :
            cnt += 1
            break
        if sum > M :
            break
print(cnt)
'''
#흠 시간제한에 걸린다라.
#이중 for 문 이라서 그런가보다.
#i, j = 0, 0
#cnt, sum = 0, 0
#while i < N :
#    if sum < M :
#        if j < N - 1 :
#            j += 1
#            sum += numArr[j]
#    #합이 같다면 새로운 연속합을 구하기 위해 i 가 움직여야한다.
#    if sum == M :
#        if i < j: i += 1
#        else: j += 1
#        cnt += 1
#        sum = 0
#        continue
#    #합이 더 크고 한 번 커지면 같아질 수가 없기에 i 가 움직여서
#    #새로운 연속합을 구하여야한다.
#    if sum > M :
#        i += 1
#        sum = 0
#        continue
#print(cnt)
#미완성 코드
#포인터를 두 개나 잡는데 while 문은 역시 무리인걸까.

#단순하게 생각해보자
#첫번째 풀이에서는 for 문을 두 번 쓰면서
#포인터 제어를 깔끔하게 해냈지.
#그 때 제어하는 방식은 어떤 방식이었지??
#쉽게 말해서 for 문을 찢어서 while 문으로 재조립 해보자는거다.
#i, j = 0, 0
#cnt, sum = 0, 0
#while i < N - 1:
#    if sum == 0: sum += numArr[i]
#    #항상 조건을 주의해서 봐야해
#    #그러기 위해서는 문제의 틀만 잡고 코드를 짜는 습관보다는
#    #틀을 잡고 예외사항을 정리해두고
#    #코드에 진입하는게 좋겠지.
#
#    #생각지도 못한 예외사항들이 등장하곤한다.
#    #코드가 디테일할수록 좋은거같다.
#    #틀을 잡고
#    #디테일하게 작성하고
#    #쳐내는 방식이 좋은걸까??
#    if sum < M :
#        if j < N - 1:
#            j += 1
#            sum += numArr[j]
#    #아래가 elif 라면
#    #합을 한뒤에 그 합에 대한 검사를 진행하지않고
#    #다음 idx 로 접근하게된다.
#    #따라서 합을 했으면 검사할 수 있도록 코드를 수정하였다.
#    if sum == M :
#        cnt += 1
#        i += 1
#        j = i + 1
#        sum = 0
#    if sum > M :
#        i += 1
#        j = i + 1
#        sum = 0
#print(cnt)
#흐아 포기
#포인터 컨트롤이 어려웡
#이것도 미완성

#하지만 포기하지 않지.
#i, j = 0, 0
#cnt, sum = 0, 0
#while i < N - 1 :
#    if sum < M :
#        if j < N :
#            sum += numArr[j]
#            j += 1
#    elif sum == M :
#        sum = 0
#        cnt += 1
#        i = j - 1
#    else :
#        sum = 0
#        i = j - 1
#print(cnt)
#이건 인정하자.
#빼기라는 발상은 좋은 발상이야.
#그냥 빼기에 집중하기보다는 포인터를 이동시키는데
#필요한 행위가 무엇인지에 좀 더 집중해서 보자.

#sum 값은 i 부터 j 까지의 합이다.
#sum 의 값을 구하는 방식에는
#매번 i 부터 j 까지의 합을 구하는 방식도 있겠지만
#이번 문제에서는 마치 지렁이가 기어가듯이 연속된 합이기에
#j 가 옮겨질때는 더하고 i 가 옮겨질때에는 빼는 방식을 취하면
#i 부터 j 까지의 합을 유지할 수 가 있다.
#나는 처음에는 sum 값이 M 이 되거나 M 보다 커지면
#sum 을 0 으로 초기화 시켜서
#다시 합을 구해나가려고 하였다.
#물론 이런 방식으로도 구현하려면 구현할 수 있을것이다.
#하지만 해당 문제에서는 그럴 필요가 없다. 기존 sum 을 가지고도
#충분히 i 부터 j 까지의 합을 구할 수 있기 때문이다.

#또한 포인터에 대한 이야기를 해보자면
#1. 포인터가 이동하는 조건
#2. 포인터가 이동하면서 해야하는 행위
#3. 포인터가 멈추어야하는 순간 또는 포인터의 끝지점
#4. 반대로 포인터의 시작지점
#이 부분들을 가지고 놀 수 있을정도로 포인터에 대해 깨우쳐야한다.
#추후 문제들에서 보자.
i, j = 0, 0
cnt, sum = 0, 0
while i < N :
    if sum < M :
        #우변의 값이 좌변의 최종 값이 될것이다!!
        if j < N :
            sum += numArr[j]
            j += 1
        else: i += 1
    if sum == M :
        cnt += 1
        sum -= numArr[i]
        i += 1
    if sum > M :
        sum -= numArr[i]
        i += 1
print(cnt)
#와 그래도 이걸 해냈다.
#머리 깨질뻔 ㅋㅋ
#포인터를 갖고 놀기위해선 필요한 시간이었어.