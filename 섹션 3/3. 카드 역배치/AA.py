import sys
#sys.stdin = open('input.txt')

#바보냐 ㅋㅋ 야 이거 까먹으면 어캄.
a = list(range(21))
#i 가 아닌 _ 를 이용시 아무런 변수 없이 돌아가는 for 문이 된다.
for _ in range(10) :
    s, e = map(int, input().split())
    #오호 나의 times 변수와 비슷한 방식이다.
    #다만 + 1 하고 2 를 나눈 몫이냐
    #몫에다가 + 1 를 했느냐 차이인데
    #차이는 없을것같다.
    #왜냐하면 + 1 한다음에 // 2 를 하면 어차피 초과된 나머지는 버리니까.
    #// 2 한다음에 + 1 을 하면 초과된 나머지는 버리고 + 1 하니까 같을 것이다.
    #아니 달라 두개는 달라
    #ex) s = 3, e = 7 이라고 생각해봐.
    #하나는 2 가 되고 하나는 3 이 되어버려
    #그리고 접근방식이 달라
    #range 는 특정 값 - 1 까지만 도니까.
    #나는 e - s 까지 돌리기위해서 나중에 + 1 한거고
    #여기서는 그냥 나중에 + 1 할 필요없이 e - s + 1 해버린거고
    #내꺼가 덜 헷갈려.
    #내꺼가 짱이네. ㅋㅋ
    #아냐아냐 너 지금 배고프고 집중력 떨어졌구나??
    #다시 한번 봐바.
    #센세 방식은 중간 idx 를 안써
    #내 방식은 중간 idx 를 써
    #그 차이야 이게 포인트야
    #정리해 보자
    #(e - s + 1) // 2 -> 중간 idx 까지 접근 안한다.
    #(e - s) // 2 + 1 -> 중간 idx 까지 접근 한다.
    #이건 매우 중요해!!

    #1 부터 반복횟수까지
    #i 를 반복횟수로 두고
    #s 랑 e 는 건드리지 않고
    #i 만 변경시켜서 포인터 이동!!
    # 훌륭한 코드다. 효율적이야!!
    for i in range((e - s + 1) // 2) :
        a[s + i], a[e - i] = a[e - i], a[s + i]
#나처럼 idx 를 그냥 - 1 생각하면서 작업해도 되지만
#이렇게 그냥 0 까지 포함시켜버려서 idx 와 val 을 동일화시키고
#마지막에 필요없는 녀석을 제거하는 방법도 있다.
#이 방법이 유효한건 idx 와 val 을 동일화시킬때 서로 1 정도만 차이나기때문이다.
#다른 경우에서는 오히려 독이 될 것 같은 방법이다.
a.pop(0)
for x in a :
    print(x, end = " ")